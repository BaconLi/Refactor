# 代码的坏味道
## 1 神秘命名（Mysterious Name）
## 2 重复代码（Duplicated Code）
## 3 过⻓函数（Long Function）
我们遵循这样⼀条原则：
每当感觉需要以注释来说明点什么的时候，我们就把需要说明的东⻄写进⼀个独立函数中，并以其⽤途（⽽⾮实现⼿法）命名。

>百分之九⼗九的场合⾥，要把函数变短，只需使⽤提炼函数（106）。
>找到函数中适合集中在⼀起的部分，将它们提炼出来形成⼀个新函数。
>如果函数内有⼤量的参数和临时变量，它们会对你的函数提炼形成阻碍。
>如果你尝试运⽤提炼函数（106），最终就会把许多参数传递给被提炼出来的新函数，导致可读性⼏乎没有任何提升。
>此时，你可以经常运⽤以查询取代临时变量（178）来消除这些临时元素。
>引⼊参数对象（140）和保持对象完整（319）则可以将过⻓的参数列表变得更简洁⼀些。
>如果你已经这么做了，仍然有太多临时变量和参数，那就应该使出我们的杀⼿锏——以命令取代函数（337）。

>条件表达式和循环常常也是提炼的信号。
>你可以使⽤分解条件表达式（260）处理条件表达式。
>对于庞⼤的 switch 语句，其中的每个分⽀都应该通过提炼函数（106）变成独立的函数调⽤。
>如果有多个switch 语句基于同⼀个条件进⾏分⽀选择，就应该使⽤以多态取代条件表达式（272）。

>⾄于循环，你应该将循环和循环内的代码提炼到⼀个独立的函数中。
>如果你发现提炼出的循环很难命名，可能是因为其中做了⼏件不同的事。
>如果是这种情况，请勇敢地使⽤拆分循环（227）将其拆分成各⾃独立的任务。

## 4 过⻓参数列表（Long Parameter List）
>如果可以向某个参数发起查询⽽获得另⼀个参数的值，那么就可以使⽤以查询取代参数（324）去掉这第⼆个参数。
>如果你发现⾃⼰正在从现有的数据结构中抽出很多数据项，就可以考虑使⽤保持对象完整（319）⼿法，直接传⼊原来的数据结构。
>如果有⼏项参数总是同时出现，可以⽤引⼊参数对象（140）将其合并成⼀个对象。
>如果某个参数被⽤作区分函数⾏为的标记（flag），可以使⽤移除标记参数（314）。

>使⽤类可以有效地缩短参数列表。如果多个函数有同样的⼏个参数，引⼊⼀个类就尤为有意义。
>你可以使⽤函数组合成类（144），将这些共同的参数变成这个类的字段。
>如果戴上函数式编程的帽⼦，我们会说，这个重构过程创造了⼀组部分应⽤函数（partially applied function）。

## 5 全局数据（Global Data）
**全局数据是最刺⿐的坏味道之⼀**
全局数据的问题在于，从代码库的任何⼀个⻆落都可以修改它，⽽且没有任何机制可以探测出到底哪段代码做出了修改。
全局数据造成的那些诡异的bug，⽽问题的根源却在遥远的别处，想要找到出错的代码难于登天。
全局数据最显⽽易⻅的形式就是全局变量，但类变量和单例（singleton）也有这样的问题。

>⾸要的防御⼿段是封装变量（132），每当我们看到可能被各处的代码污染的数据，这总是我们应对的第⼀招。
>你把全局数据⽤⼀个函数包装起来，⾄少你就能看⻅修改它的地⽅，并开始控制对它的访问。
>随后，最好将这个函数（及其封装的数据）搬移到⼀个类或模块中，只允许模块内的代码使⽤它，从⽽尽量控制其作⽤域。
>可以被修改的全局数据尤其可憎。如果能保证在程序启动之后就不再修改，这样的全局数据还算相对安全，不过得有编程语⾔提供这样的保证才⾏。

## 6 可变数据（Mutable Data）
对数据的修改经常导致出乎意料的结果和难以发现的bug。
我在⼀处更新数据，却没有意识到软件中的另⼀处期望着完全不同的数据，于是⼀个功能失效了——如果故障只在很罕⻅的情况下发⽣，要找出故障原因就会更加困难。

>可以⽤封装变量（132）来确保所有数据更新操作都通过很少⼏个函数来进⾏，使其更容易监控和演进。
>如果⼀个变量在不同时候被⽤于存储不同的东⻄，可以使⽤拆分变量（240）将其拆分为各⾃不同⽤途的变量，从⽽避免危险的更新操作。
>使⽤移动语句（223）和提炼函数（106）尽量把逻辑从处理更新操作的代码中搬移出来，将没有副作⽤的代码与执⾏数据更新操作的代码分开。
>设计API时，可以使⽤将查询函数和修改函数分离（306）确保调⽤者不会调到有副作⽤的代码，除⾮他们真的需要更新数据。
>我们还乐于尽早使⽤移除设值函数（331）——有时只是把设值函数的使⽤者找出来看看，就能帮我们发现缩⼩变量作⽤域的机会。

>如果可变数据的值能在其他地⽅计算出来，这就是⼀个特别刺⿐的坏味道。
>它不仅会造成困扰、bug和加班，⽽且毫⽆必要。
>消除这种坏味道的办法很简单，使⽤以查询取代派⽣变量（248）即可。

如果变量作⽤域只有⼏⾏代码，即使其中的数据可变，也不是什么⼤问题；但随着变量作⽤域的扩展，⻛险也随之增⼤。
可以⽤函数组合成类（144）或者函数组合成变换（149）来限制需要对变量进⾏修改的代码量。
如果⼀个变量在其内部结构中包含了数据，通常最好不要直接修改其中的数据，⽽是⽤将引⽤对象改为值对象（252）令其直接替换整个数据结构。

## 7 发散式变化（Divergent Change）

每当要对某个上下⽂做修改时，我们只需要理解这个上下⽂，⽽不必操⼼另⼀个。“每次只关⼼⼀个上下⽂”这⼀点⼀直很重要。

如果发⽣变化的两个⽅向⾃然地形成了先后次序（⽐如说，先从数据库取出数据，再对其进⾏⾦融逻辑处理），就可以⽤拆分阶段（154）将两者分开，两者之间通过⼀个清晰的数据结构进⾏沟通。
如果两个⽅向之间有更多的来回调⽤，就应该先创建适当的模块，然后⽤搬移函数（198）把处理逻辑分开。
如果函数内部混合了两类处理逻辑，应该先⽤提炼函数（106）将其分开，然后再做搬移。如果模块是以类的形式定义的，就可以⽤提炼类（182）来做拆分。

## 8 霰弹式修改（Shotgun Surgery）
如果每遇到某种变化，你都必须在许多不同的类内做出许多⼩修改，你所⾯临的坏味道就是霰弹式修改。
如果需要修改的代码散布四处，你不但很难找到它们，也很容易错过某个重要的修改。

>这种情况下，你应该使⽤搬移函数（198）和搬移字段（207）把所有需要修改的代码放进同⼀个模块⾥。
>如果有很多函数都在操作相似的数据，可以使⽤函数组合成类（144）。
>如果有些函数的功能是转化或者充实数据结构，可以使⽤函数组合成变换（149）。
>如果⼀些函数的输出可以组合后提供给⼀段专⻔使⽤这些计算结果的逻辑，这种时候常常⽤得上拆分阶段（154）。

## 9 依恋情结（Feature Envy）
所谓模块化，就是⼒求将代码分出区域，最⼤化区域内部的交互、最⼩化跨区域的交互。
但有时你会发现，⼀个函数跟另⼀个模块中的函数或者数据交流格外频繁，远胜于在⾃⼰所处模块内部的交流，这就是依恋情结的典型情况。

>⽆数次经验⾥，我们看到某个函数为了计算某个值，从另⼀个对象那⼉调⽤⼏乎半打的取值函数。
>疗法显⽽易⻅：这个函数想跟这些数据待在⼀起，那就使⽤搬移函数（198）把它移过去。
>有时候，函数中只有⼀部分受这种依恋之苦，这时候应该使⽤提炼函数（106）把这⼀部分提炼到独立的函数中，再使⽤搬移函数（198）带它去它的梦想家园。

>⼀个函数往往会⽤到⼏个模块的功能，那么它究竟该被置于何处呢？
>我们的原则是：判断哪个模块拥有的此函数使⽤的数据最多，然后就把这个函数和那些数据摆在⼀起。
>如果先以提炼函数（106）将这个函数分解为数个较⼩的函数并分别置放于不同地点，上述步骤也就⽐较容易完成了。

## 10 数据泥团（Data Clumps）
数据项就像⼩孩⼦，喜欢成群结队地待在⼀块⼉。
你常常可以在很多地⽅看到相同的三四项数据：两个类中相同的字段、许多函数签名中相同的参数。
这些总是绑在⼀起出现的数据真应该拥有属于它们⾃⼰的对象。

>⾸先请找出这些数据以字段形式出现的地⽅，运⽤提炼类（182）将它们提炼到⼀个独立对象中。
>然后将注意⼒转移到函数签名上，运⽤引⼊参数对象（140）或保持对象完整（319）为它瘦身。
>这么做的直接好处是可以将很多参数列表缩短，简化函数调⽤。
>是的，不必在意数据泥团只⽤上新对象的⼀部分字段，只要以新对象取代两个（或更多）字段，就值得这么做。

## 11 基本类型偏执（Primitive Obsession）

很多程序员不愿意创建对⾃⼰的问题域有⽤的基本类型，如钱、坐标、范围等。
于是，我们看到了把钱当作普通数字来计算的情况、计算物理量时⽆视单位（如把英⼨与毫⽶相加）的情况以及⼤量类似 if (a < upper && a > lower) 这样的代码。

>你可以运⽤以对象取代基本类型（174）将原本单独存在的数据值替换为对象，从⽽⾛出传统的洞窟，进⼊炙⼿可热的对象世界。
>如果想要替换的数据值是控制条件⾏为的类型码，则可以运⽤以⼦类取代类型码（362）加上以多态取代条件表达式（272）的组合将它换掉。
>如果你有⼀组总是同时出现的基本类型数据，这就是数据泥团的征兆，应该运⽤提炼类（182）和引⼊参数对象（140）来处理。

## 12 重复的switch （Repeated Switches）
如果你跟真正的⾯向对象布道者交谈，他们很快就会谈到 switch 语句的邪恶。
在他们看来，任何 switch语句都应该⽤以多态取代条件表达式（272）消除掉。
我们甚⾄还听过这样的观点：所有条件逻辑都应该⽤多态取代，绝⼤多数 if 语句都应该被扫进历史的垃圾桶。

>关注重复的 switch ：在不同的地⽅反复使⽤同样的 switch 逻辑（可能是以 switch/case 语句的形式，也可能是以连续的 if/else 语句的形式）。
>重复的 switch 的问题在于：每当你想增加⼀个选择分⽀时，必须找到所有的 switch ，并逐⼀更新。多态给了我们对抗这种⿊暗力量的武器，使我们得到更优雅的代码库。

## 13 循环语句（Loops）
使⽤以管道取代循环（231）来让这些⽼古董退休。
我们发现，管道操作（如filter和map）可以帮助我们更快地看清被处理的元素以及处理它们的动作。

## 14 冗赘的元素（Lazy Element）
可能有这样⼀个函数，它的名字就跟实现代码看起来⼀模⼀样；也可能有这样⼀个类，根本就是⼀个简单的函数。
这可能是因为，起初在编写这个函数时，程序员也许期望它将来有⼀天会变⼤、变复杂，但那⼀天从未到来；也可能是因为，这个类原本是有⽤的，但随着重构的进⾏越变越⼩，最后只剩了⼀个函数。
不论上述哪⼀种原因，请让这样的程序元素庄严赴义吧。
>通常你只需要使⽤内联函数（115）或是内联类（186）。
>如果这个类处于⼀个继承体系中，可以使⽤折叠继承体系（380）。

## 15 夸夸其谈通⽤性（Speculative Generality）
当有⼈说“噢，我想我们总有⼀天需要做这事”，并因⽽企图以各式各样的钩⼦和特殊情况来处理⼀些⾮必要的事情，这种坏味道就出现了。

>如果你的某个抽象类其实没有太⼤作⽤，请运⽤折叠继承体系（380）。
>不必要的委托可运⽤内联函数（115）和内联类（186）除掉。
>如果函数的某些参数未被⽤上，可以⽤改变函数声明（124）去掉这些参数。
>如果有并⾮真正需要、只是为不知远在何处的将来⽽塞进去的参数，也应该⽤改变函数声明（124）去掉。
>如果函数或类的唯⼀⽤户是测试⽤例，这就飘出了坏味道“夸夸其谈通⽤性”。如果你发现这样的函数或类，可以先删掉测试⽤例，然后使⽤移除死代码（237）。

## 16 临时字段（Temporary Field）
有时你会看到这样的类：其内部某个字段仅为某种特定情况⽽设。
这样的代码让⼈不易理解，因为你通常认为对象在所有时候都需要它的所有字段。在字段未被使⽤的情况下猜测当初设置它的⽬的，会让你发疯。

>请使⽤提炼类（182）给这个可怜的孤⼉创造⼀个家，然后⽤搬移函数（198）把所有和这些字段相关的代码都放进这个新家。
>也许你还可以使⽤引⼊特例（289）在“变量不合法”的情况下创建⼀个替代对象，从⽽避免写出条件式代码。

## 17 过⻓的消息链（Message Chains）
如果你看到⽤户向⼀个对象请求另⼀个对象，然后再向后者请求另⼀个对象，然后再请求另⼀个对象……这就是消息链。
>这时候应该使⽤隐藏委托关系（189）。你可以在消息链的不同位置采⽤这种重构⼿法。
>通常更好的选择是：先观察消息链最终得到的对象是⽤来⼲什么的，看看能否以提炼函数（106）把使⽤该对象的代码提炼到⼀个独立的函数中，再运⽤搬移函数（198）把这个函数推⼊消息链。   

## 18 中间⼈（Middle Man）
对象的基本特征之⼀就是封装——对外部世界隐藏其内部细节。封装往往伴随着委托。
⽐如，你问主管是否有时间参加⼀个会议，他就把这个消息“委托”给他的记事簿，然后才能回答你。
很好，你没必要知道这位主管到底使⽤传统记事簿还是使⽤电⼦记事簿抑或是秘书来记录⾃⼰的约会。

>但是⼈们可能过度运⽤委托。你也许会看到某个类的接⼝有⼀半的函数都委托给其他类，这样就是过度运⽤。
>这时应该使⽤移除中间⼈（192），直接和真正负责的对象打交道。
>如果这样“不⼲实事”的函数只有少数⼏个，可以运⽤内联函数（115）把它们放进调⽤端。
>如果这些中间⼈还有其他⾏为，可以运⽤以委托取代超类（399）或者以委托取代⼦类（381）把它变成真正的对象，这样你既可以扩展原对象的⾏为，⼜不必负担那么多的委托动作。

## 19 内幕交易（Insider Trading）
软件开发者喜欢在模块之间建起⾼墙，极其反感在模块之间⼤量交换数据，因为这会增加模块间的耦合。
在实际情况⾥，⼀定的数据交换不可避免，但我们必须尽量减少这种情况，并把这种交换都放到明⾯上来。

>如果两个模块总是在咖啡机旁边窃窃私语，就应该⽤搬移函数（198）和搬移字段（207）减少它们的私下交流。
>如果两个模块有共同的兴趣，可以尝试再新建⼀个模块，把这些共⽤的数据放在⼀个管理良好的地⽅；或者⽤隐藏委托关系（189），把另⼀个模块变成两者的中介。
>继承常会造成密谋，因为⼦类对超类的了解总是超过后者的主观愿望。如果你觉得该让这个孩⼦独⽴⽣活了，请运⽤以委托取代⼦类（381）或以委托取代超类（399）让它离开继承体系。

## 20 过⼤的类（Large Class）
如果想利⽤单个类做太多事情，其内往往就会出现太多字段。⼀旦如此，᯿复代码也就接踵⽽⾄了。
>你可以运⽤提炼类（182）将⼏个变量⼀起提炼⾄新类内。提炼时应该选择类内彼此相关的变量，将它们放在⼀起。
>通常，如果类内的数个变量有着相同的前缀或后缀，这就意味着有机会把它们提炼到某个组件内。
>如果这个组件适合作为⼀个⼦类，你会发现提炼超类（375）或者以⼦类取代类型码（362）（其实就是提炼⼦类）往往⽐较简单。
>看看使⽤者是否只⽤到了这个类所有功能的⼀个⼦集，每个这样的⼦集都可能拆分成⼀个ᇿ⽴的类。
>⼀旦识别出⼀个合适的功能⼦集，就试⽤提炼类（182）、提炼超类（375）或是以⼦类取代类型码（362）将其拆分出来。

## 21 异曲同⼯的类（Alternative Classes with Different Interfaces）
使⽤类的好处之⼀就在于可以替换：今天⽤这个类，未来可以换成⽤另⼀个类。但只有当两个类的接⼝⼀致时，才能做这种替换。
>可以⽤改变函数声明（124）将函数签名变得⼀致。但这往往还不够，请反复运⽤搬移函数（198）将某些⾏为移⼊类中，直到两者的协议⼀致为⽌。
>如果搬移过程造成了᯿复代码，或许可运⽤提炼超类（375）补偿⼀下。

## 22 纯数据类（Data Class）
所谓纯数据类是指：它们拥有⼀些字段，以及⽤于访问（读写）这些字段的函数，除此之外⼀⽆⻓物。
>这样的类只是⼀种不会说话的数据容器，它们⼏乎⼀定被其他类过分细琐地操控着。
>这些类早期可能拥有 public 字段，若果真如此，你应该在别⼈注意到它们之前，⽴刻运⽤封装记录（162）将它们封装起来。
>对于那些不该被其他类修改的字段，请运⽤移除设值函数（331）。
>纯数据类常常意味着⾏为被放在了错误的地⽅。也就是说，只要把处理数据的⾏为从客户端搬移到纯数据类⾥来，就能使情况⼤为改观。

有例外情况，⼀个最好的例外情况就是，纯数据记录对象被⽤作函数调⽤的返回结果。⽐如使⽤拆分阶段（154）之后得到的中转数据结构就是这种情况。
这种结果数据对象有⼀个关键的特征：它是不可修改的（⾄少在拆分阶段（154）的实际操作中是这样）。不可修改的字段⽆须封装，使⽤者可以直接通过字段取得数据，⽆须通过取值函数。

## 23 被拒绝的遗赠（Refused Bequest）
⼦类应该继承超类的函数和数据。但如果它们不想或不需要继承，⼜该怎么办呢？它们得到所有礼物，却只从中挑选⼏样来玩！
>按传统说法，这就意味着继承体系设计错误。你需要为这个⼦类新建⼀个兄弟类，再运⽤函数下移（359）和字段下移（361）把所有⽤不到的函数下推给那个兄弟。这样⼀来，超类就只持有所有⼦类共享的东⻄。

既然使⽤“传统说法”这个略带贬义的词，你就可以猜到，我们不建议你这么做，起码不建议你每次都这么做。
我们经常利⽤继承来复⽤⼀些⾏为，并发现这可以很好地应⽤于⽇常⼯作。这也是⼀种坏味道，我们不否认，但⽓味通常并不强烈，所以我们说，如果“被拒绝的遗赠”正在引起困惑和问题，请遵循传统忠告。
但不必认为你每次都得那么做。⼗有⼋九这种坏味道很淡，不值得理睬。

如果⼦类复⽤了超类的⾏为（实现），却⼜不愿意⽀持超类的接⼝，“被拒绝的遗赠”的坏味道就会变得很浓烈。
拒绝继承超类的实现，这⼀点我们不介意；但如果拒绝⽀持超类的接⼝，这就难以接受了。
既然不愿意⽀持超类的接⼝，就不要虚情假意地糊弄继承体系，应该运⽤以委托取代⼦类（381）或者以委托取代超类（399）彻底划清界限。

## 24 注释（Comments）
常常会有这样的情况：你看到⼀段代码有着⻓⻓的注释，然后发现，这些注释之所以存在乃是因为代码很糟糕。这种情况的发⽣次数之多，实在令⼈吃惊。
注释可以带我们找到本章先前提到的各种坏味道。找到坏味道后，我们⾸先应该以各种重构⼿法把坏味道去除。完成之后我们常常会发现：注释已经变得多余了，因为代码已经清楚地说明了⼀切。
>如果你需要注释来解释⼀块代码做了什么，试试提炼函数（106）；
>如果函数已经提炼出来，但还是需要注释来解释其⾏为，试试⽤改变函数声明（124）为它改名；
>如果你需要注释说明某些系统的需求规格，试试引⼊断⾔（302）。






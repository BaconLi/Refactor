# 重构的原则
## 1 何谓重构

>“重构”这个词既可以用作名词也可以用作动词。
>
>重构 （名词）：对软件内部结构的一种调整，目的是在不改变软件可观察行为的前提下，提高其可理解性，降低其修改成本。
>
>重构 （动词）：使用一系列重构手法，在不改变软件可观察行为的前提下，调整其结构。

重构的关键在于运用大量微小且保持软件⾏为的步骤，⼀步步达成⼤规模的修改。每个单独的重构要么很⼩，要么由若⼲⼩步骤组合⽽成。
在重构的过程中，我的代码很少进⼊不可⼯作的状态，即便重构没有完成，我也可以在任何时刻停下来。

重构是为了让代码“更容易理解，更易于修改”。这可能使程序运⾏得更快，也可能使程序运⾏得更慢。
在性能优化时，我只关⼼让程序运⾏得更快，最终得到的代码有可能更难理解和维护，对此我有⼼理准备。

## 2 为何重构
如果没有重构，程序的内部设计（或者叫架构）会逐渐腐败变质。
>当⼈们只为短期⽬的⽽修改代码时，他们经常没有完全理解架构的整体设计，于是代码逐渐失去了⾃⼰的结构。
程序员越来越难通过阅读源码来理解原来的设计。代码结构的流失有累积效应。越难看出代码所代表的设计意图，就越难保护其设计，于是设计就腐败得越快。
经常性的重构有助于代码维持⾃⼰该有的形态。

通过重构消除重复代码
>完成同样⼀件事，设计⽋佳的程序往往需要更多代码，这常常是因为代码在不同的地⽅使⽤完全相同的语句做同样的事，因此改进设计的⼀个重要⽅向就是消除重复代码。
代码量减少并不会使系统运⾏更快，因为这对程序的资源占⽤⼏乎没有任何明显影响。然⽽代码量减少将使未来可能的程序修改动作容易得多。

>消除重复代码是优秀设计的根本。

重构可以帮我让代码更易读
>对代码的理解，可以帮我找到bug。对代码进⾏重构，可以深⼊理解代码的所作所为，并⽴即把新的理解反映在代码当中。

前⾯的⼀切都归结到了这⼀点：重构帮我更快速地开发程序。

## 3 何时重构
添加新功能之前
>在动⼿添加新功能之前，我会看看现有的代码库。
>此时经常会发现：如果对代码结构做⼀点微调，我的⼯作会容易得多。
>也许已经有个函数提供了我需要的⼤部分功能，但有⼏个字⾯量的值与我的需要略有冲突。
>如果不做重构，我可能会把整个函数复制过来，修改这⼏个值，但这就会导致重复代码。
>如果将来我需要做修改，就必须同时修改两处（更麻烦的是，我得先找到这两处）。
>⽽且，如果将来我还需要⼀个类似⼜略有不同的功能，就只能再复制粘贴⼀次，这可不是个好主意。
>所以我戴上重构的帽⼦，使⽤函数参数化（310）。做完这件事以后，接下来我就只需要调⽤这个函数，传⼊我需要的参数。

修复bug时
>在寻找问题根因时，我可能会发现：
>如果把3段⼀模⼀样且都会导致错误的代码合并到⼀处，问题修复起来会容易得多。
>或者，如果把某些更新数据的逻辑与查询逻辑分开，会更容易避免造成错误的逻辑纠缠。
>⽤重构改善这些情况，在同样场合再次出现同样bug的概率也会降低。

需要先理解代码在做什么，然后才能着⼿修改
>⼀旦我需要思考“这段代码到底在做什么”，我就会⾃问：能不能重构这段代码，令其⼀⽬了然？
>我可能看⻅了⼀段结构糟糕的条件逻辑
>也可能希望复⽤⼀个函数，但花费了⼏分钟才弄懂它到底在做什么，因为它的函数命名实在是太糟糕了。
>这些都是重构的机会。

通过重构，我就把脑⼦⾥的理解转移到了代码本身。
把对代码的理解植⼊代码中，这份知识会保存得更久，并且我的同事也能看到。
重构带来的帮助不仅发⽣在将来——常常是⽴竿⻅影。
我会先在⼀些⼩细节上使⽤重构来帮助理解。
给⼀两个变量改名，让它们更清楚地表达意图，以⽅便理解，或是将⼀个⻓函数拆成⼏个⼩函数。
当代码变得更清晰⼀些时，我就会看⻅之前看不⻅的设计问题。

另⼀种情况是，如果重写⽐重构还容易，就别重构了。
这是个困难的决定。如果不花⼀点⼉时间尝试，往往很难真实了解重构⼀块代码的难度。
决定到底应该重构还是重写，需要良好的判断⼒与丰富的经验，我⽆法给出⼀条简单的建议。



